1.在一个JVM中可能存在多个ClassLoader，每个ClassLoader拥有自己的NameSpace。
一个ClassLoader只能拥有一个class对象类型的实例，但是不同的ClassLoader可能拥有相同的class对象实例，
这时可能产生致命的问题。如ClassLoaderA，装载了类A的类型实例A1，而ClassLoaderB，也装载了类A的对象实例A2。
逻辑上讲A1=A2，但是由于A1和A2来自于不同的ClassLoader，它们实际上是完全不同的，如果A中定义了一个静态变量c，
则c在不同的ClassLoader中的值是不同的。

	/**
	 * class.forName(1,2,3) class.forName(1) :
	 * 我得到以下Y:不管您使用的是new 懋a生某e的w、或是使用只有一档
	 * forName()方法，炔慷茧[含了”d入e+呼叫oB初始化^K”的幼鳌６使用具有三档
	 * forName()方法r，如果第二到o定的是false，那N就只命令ed入器d入e，但不
	 * 叫用其oB初始化^K，只有等到整程式第一次w化某er，oB初始化^K才被叫
	 * 用。
	 * 直接使用ClassLoader e的loadClass()方法磔d入e，只把ed入w，
	 * K不叫用e的oB初始化^K，而必等到第一次w化er，e的oB初始化^K才被叫用。
	 * @N情形c使用Class e的forName()方法r，第二魅false缀跏窍嗤的Y果。
	 */	
	
	/**
	 * 使用线程上下文类加载器, 可以在执行线程中, 抛弃双亲委派加载链模式, 使用线程上下文里的类加载器加载类.
	 * 典型的例子有, 通过线程上下文来加载第三方库jndi实现, 而不依赖于双亲委派.
	 * 大部分java app服务器(jboss, tomcat..)也是采用contextClassLoader来处理web服务。
	 * 用Class.forName加载类:
	 * Class.forName使用的是被调用者的类加载器来加载类的.
	 * 这种特性, 证明了java类加载器中的名称空间是唯一的, 不会相互干扰.
	 * 即在一般情况下, 保证同一个类中所关联的其他类都是由当前类的类加载器所加载的.
	 */


2.使用线程上下文类加载器, 可以在执行线程中, 抛弃双亲委派加载链模式, 使用线程上下文里的类加载器加载类.
	典型的例子有, 通过线程上下文来加载第三方库jndi实现, 而不依赖于双亲委派.
	大部分java app服务器(jboss, tomcat..)也是采用contextClassLoader来处理web服务。
	用Class.forName加载类:
	Class.forName使用的是被调用者的类加载器来加载类的.
	这种特性, 证明了java类加载器中的名称空间是唯一的, 不会相互干扰.
	即在一般情况下, 保证同一个类中所关联的其他类都是由当前类的类加载器所加载的.

3.关键字:   ContextClassLoader     
问 : 我什么时候应该使用 Thread.getContextClassLoader()? 

答 : 这个问题经常出现在编写框架代码 , 需要动态加载很多类和资源的时候 . 通常当你需要动态加载资源的时候 , 
	你至少有三个 ClassLoader 可以选择 : 
	系统类加载器或叫作应用类加载器 (system classloader or application classloader) 
	当前类加载器 
	当前线程类加载器 
	上面的问题指的是最后一种类加载器 . 哪种类加载器是正确的选择呢 ? 

	第一种选择可以很容易地排除 : 系统类加载器 (system classloader). 这个类加载器处理 -classpath 下的类加载工作 , 
	可以通过 ClassLoader.getSystemClassLoader() 方法调用 . ClassLoader 下所有的 getSystemXXX() 的静态方法
	都是通过这个方法定义的 . 在你的代码中 , 你应该尽量少地调用这个方法 , 以其它的类加载器作为代理 . 否则你的代码将只能
	工作在简单的命令行应用中 , 这个时候系统类加载器 (system classloader) 是 JVM 最后创建的类加载器. 一但你把代码
	移到 EJB, Web 应用或 Java Web Start 应用中,一定会出问题. 

     所以我们来看第二种选择:当前上下文环境下的类加载器.根据定义,当前类加载器就是你当前方法所属的类的加载器.在运行时类之间动态联编,
     及调用 Class.forName,() Class.getResource() 等类似方法时,这个类加载器会被隐含地使用.It is also used by syntactic
    constructs like X.class class literals. 
     线程上下文类型加载器是在Java 2平台上被引入的.每一个线程都有一个类加载器与之对应(除非这个线程是被本地代码创建的). 这个类加载器
     是通过Thread.setContextClassLoaser()方法设置的. 如果你不在线程构造后调用这个方法, 这个线程将从它的父线程中继承相应的上下
     文类加载器. 如果在整个应用中你不做任何特殊设置, 所有的线程将都以系统类加载器(system classloader)作为自己的线程上下文类加载器.
     自从Web和J2EE应用服务器使用成熟的类加载器机制来实现诸如JNDI, 线程池, 组件热部署等功能以来, 这种在整个应用中不做任何线程类加载器
     设置的情况就很少了. 

    为什么线程上下文类加载器存在于如此重要的位置呢? 这个概念在J2SE中的引入并不引人注目. 很多开发人员对这一概念迷惑的原因是Sun公司
    在这方面缺乏适当的指引和文档.事实上, 上下文类加载器提供了类加载机制的后门, 这一点也在J2SE中被引入了.通常, 在JVM中的所有类加载
    器被组织成了有继承层次的结构,每一个类加载器(除了引导JVM的原始类加载器)都有一个父加载器.每当被请示加载类时, 类加载器都会首先请求
    其父类加载器, 只有当父类加载器不能加载时, 才会自己进行类加载.有时候这种类加载的顺序安排不能正常工作,通常当必须动态加载应用程序开
    发人员提供的资源的时候.以JNDI为例: 它的内容(从J2SE1.3开始)就在rt.jar中的引导类中实现了, 但是这些JNDI核心类需要动态加载由独
    立厂商实现并部署在应用程序的classpath下的JNDI提供者.这种情况就要求一个父classloader(本例, 就是引导类加载器)去加载对于它其
    中一个子classloader(本例, 系统类加载器)可见的类. 这时通常的类加载代理机制不能实现这个要求. 解决的办法(workaround)就是, 
    让JNDI核心类使用当前线程上下文的类加载器, 这样, 就基本的类加载代理机制的相反方向建立了一条有效的途径. 

    另外, 上面一段可能让你想起一些其它的事情:XML解析Java API(JAXP).是的, 当JAXP只是J2SE的扩展进,它很自然地用当前类加载器来引
    导解析器的实现. 而当JAXP被加入到J2SE1.4的核心类库中时, 它的类加载也就改成了用当前线程类加载器, 与JNDI的情况完全类似(也使很
    多程序员很迷惑). 明白为什么我说来自Sun的指导很缺乏了吧?
    在以上的介绍之后, 我们来看关键问题: 这两种选择(当前类加载器和当前线程类加载器)都不是在所有环境下都适用. 有些人认为当前线程类加
    载器应该成为新的标准策略. 但是, 如果这样, 当多个线程通过共享数据进行交互的时, 将会呈现出一幅极其复杂的类加载的画面, 除非它们全
    部使用了同一个上下文的类加载器. 进一步说, 在某些遗留下来的解决方案中, 委派到当前类加载器的方法已经是标准. 比如对
    Class.forName(String)的直接调用(这也是我为什么推荐尽量避免对这个方法进行调用的原因). 即使你努力去只调用上下文相关的类加载器,
    仍然会有一些代码会不由你控制. 这种不受控制的类加载委派机制是混入是很危险的. 
    更严重的问题, 某些应用服务器把环境上下文及当前类加载器设置到不同的类加载器实例上, 而这些类加载器有相同的类路径但却没有委派机制中
    的父子关系. 想想这为什么十分可怕. 要知道类加载器定义并加载的类实例会带有一个JVM内部的ID号. 如果当前类加载器加载一个类X的实例,
    这个实例调用JNDI查找类Y的实例, 些时的上下文的类加载器也可以定义了加载类Y实例. 这个类Y的定义就与当前类加载器看到的类Y的定义不同.
    如果进行强制类型转换, 则产生异常. 
    这种混乱的情况还将在Java中存在一段时间. 对于那些需要动态加载资源的J2SE的API, 我们来猜想它们的类加策略. 例如: 

	JNDI 使用线程上下文类加载器   javax.naming.ldap.StartTlsRequest
	Class.getResource() 和Class.forName()使用当前类加载器 
	JAXP(J2SE 1.4 及之后)使用线程上下文类加载器   javax.xml.parsers.SecuritySupport
	java.util.ResourceBundle 使用调用者的当前类加载器 
	URL protocol handlers specified via java.protocol.handler.pkgs system property are looked up in the bootstrap and system classloaders only 
	Java 序列化API默认使用调用者当前的类加载器 
	这些类及资源的加载策略问题, 肯定是J2SE领域中文档最及说明最缺乏的部分了. 
